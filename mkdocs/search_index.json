{
    "docs": [
        {
            "location": "/", 
            "text": "PCF Tile Generator\n\n\nThis is a tile generation utility for PCF tiles. Tiles are the\ninstallation package format used by Pivotal's Ops Manager to deploy add-on\nsoftware such as services and their brokers, buildpacks, or anything else\nthat needs to be installable in both public and private cloud deployments.\n\n\nThe current release of the tile generator supports tiles that have any\ncombination of the following package types:\n\n\n\n\nCloud Foundry Applications\n\n\nCloud Foundry Buildpacks\n\n\nCloud Foundry Service Brokers (both inside and outside the Elastic Runtime)\n\n\nDocker images (both inside and outside the Elastic Runtime)\n\n\n\n\nScreencast\n\n\nFor a 7-minute introduction into what it is and does, see\n\nthis screencast\n.\n\n\nContinuous Integration\n\n\nThe master branch of this repository is being monitored by\n\nthis Concourse pipeline\n.\nThe pipeline verifies that:\n\n\n\n\nThe tile generator passes all unit tests in \nlib/*_unittest.py\n\n\nThe tile generator successfully builds the sample tile in \nsample\n\n\nThe generated tile passes all acceptance tests in \nci/acceptance-tests\n\n\nThe generated tile successfully deploys to a current version of PCF\n\n\nThe deployed tile passes all deployment tests in \nci/deployment-tests\n\n\n\n\nHow to Use\n\n\n\n\n\n\nCheck out the tile-generator repo:\n\n\nbash\ngit clone https://github.com/cf-platform-eng/tile-generator.git\n\n\n\n\n\n\nChange to the root directory of the tile generator, and pull down the generator's dependencies:\n\n\nbash\ncd tile-generator\npip install -r requirements.txt\n\n\n\n\n\n\nAdd the \nbin\n directory of tile-generator to your path:\n\n\nbash\nexport PATH=`pwd`/bin:$PATH\n\n\nIf you expect to frequently use the tile generator, you may want to add this to your shell's startup script, i.e. \n.profile\n\n\n\n\n\n\nInstall the \nBOSH CLI\n\n\n\n\n\n\nThen, from within the root directory of the project for which you wish to create a tile, initialize it as a tile repo (we recommend that this be a git repo, but this is not required):\n\n\nbash\ncd \nyour project dir\n\ntile init\n\n\n\n\n\n\nEdit the generated \ntile.yml\n file to define your tile (more details below)\n\n\n\n\n\n\nBuild your tile\n\n\nbash\ntile build\n\n\n\n\n\n\nThe generator will first create a BOSH release (in the \nrelease\n subdirectory),\nthen wrap that release into a Pivotal tile (in the \nproduct\n subdirectory).\nIf required for the installation, it will automatically pull down the latest\nrelease version of the Cloud Foundry CLI.\n\n\nBuilding the Sample\n\n\nThe repository includes a sample tile that exercises most of the features of the\ntile generator (it is used by the CI pipeline to verify that things work correctly).\nYou can build this sample using the following steps:\n\n\ncd sample\nsrc/build.sh\ntile build\n\n\n\n\nThe sample tile includes a Python application that is re-used in several packages,\nsometimes as an app, sometimes as a service broker. One of the deployments (app3)\nuses the sample application inside a docker image that is currently only modified\nby the CI pipeline. If you modify the sample app, you will have to build your own\ndocker image using the provided \nDockerfile\n and change the image name in\n\nsample/tile.yml\n to include the modified code in app3.\n\n\nDefining your Tile\n\n\nAll required configuration for your tile is in the file called \ntile.yml\n.\n\ntile init\n will create an initial version for you that can serve as a template.\nThe first section in the file describes the general properties of your tile:\n\n\nname: tile-name # By convention lowercase with dashes\nicon_file: resources/icon.png\nlabel: Brief Text for the Tile Icon\ndescription: Longer description of the tile's purpose\n\n\n\n\nThe \nicon_file\n should be a 128x128 pixel image that will appear on your tile in\nthe Ops Manager GUI. By convention, any resources used by the tile should be\nplaced in the \nresources\n sub-directory of your repo, although this is not\nmandatory. The \nlabel\n text will appear on the tile under your icon.\n\n\nPackages\n\n\nNext you can specify the packages to be included in your tile. The format of\neach package entry depends on the type of package you are adding.\n\n\nPushed Applications\n\n\nApplications (including service brokers) that are being \ncf push\ned into the\nElastic Runtime use the following format:\n\n\n\n- name: my-application\n  type: app \nor\n app-broker\n  manifest:\n    \n# any options that you would normally specify in a cf manifest.yml, including\n\n    buildpack:\n    command:\n    domain:\n    host:\n    instances:\n    memory:\n    path:\n    env:\n    services:\n  health_check: none                 \n# optional\n\n  configurable_persistence: true     \n# optional\n\n  needs_cf_credentials: true         \n# optional\n\n  auto_services: p-mysql p-redis     \n# optional\n\n\n\n\n\nNote: for applications that are normally pushed as multiple files (node.js for example)\nyou should zip up the project files plus all dependencies into a single zip file, then\nedit tile.yml to point to the zipped file: \n\n\ncd \nyour project dir\n\nzip -r resources/\nyour project name\n.zip \nlist of file and dirs to include in the zip\n\n\n\n\n\nIf your application is a service broker, use \napp-broker\n as the type instead of just\n\napp\n. The application will then automatically be registered as a broker on install,\nand deleted on uninstall.\n\n\nhealth_check\n lets you configure the value of the cf cli \n--health_check_type\n\noption. Expect this option to move into the manifest as soon as CF supports it there.\nCurrently, the only valid options are \nnone\n and \nport\n.\n\n\nconfigurable_persistence: true\n results in the user being able to select a backing\nservice for data persistence. If there is a specific broker you want to use, you can\nuse the \nauto-services\n feature described below. If you want to bind to an already\nexisting service instance, use the \nservices\n proeprty of the \nmanifest\n instead.\n\n\nneeds_cf_credentials\n causes the application to receive two additional environment\nvariables named \nCF_ADMIN_USER\n and \nCF_ADMIN_PASSWORD\n with the admin credentials\nfor the Elastic Runtime into which they are being deployed. This allows apps and\nservices to interact with the Cloud Controller.\n\n\nauto_services\n is described in more detail below.\n\n\nService Brokers\n\n\nMost modern service brokers are pushed into the Elastic Runtime as normal\nCF applications. For these types of brokers, use the Pushed Application format\nspecified above, but set the type to \napp-broker\n or \ndocker-app-broker\n instead\nof just \napp\n or \ndocker-app\n.\n\n\nSome service brokers support operator-defined service plans, for instance when\nthe plans reflect customer license keys. To allow operators to add plans from\nthe tile configuration, add the following section:\n\n\n\ndynamic_service_plans:\n- name: description\n  type: string\n  description: \"Some Description\"\n  configurable: true\n- name: key1\n  type: integer\n  description: \"Key 1 of type integer\"\n  configurable: true\n- name: key2\n  type: secret\n  description: \"Key 2 of type Password\"\n  configurable: true\n\n\n\n\nName and GUID fields will be supplied by default for each plan, but all other fields\nare optional and customizable.\n\n\nFor an external service broker, use:\n\n\n\n- name: my-application\n  type: external-broker\n  uri: http://broker3.example.com\n  username: user\n  password: \nsecret\n\n  internal_service_names: 'service1,service2'\n\n\n\n\nBuildpacks\n\n\n\n- name: my-buildpack\n  type: buildpack\n  files:\n  - path: resources/buildpack.zip\n\n\n\n\nDocker Images\n\n\nApplications packages as docker images can be deployed inside or outside the Elastic\nRuntime. To push a docker image as a CF application, use the \nPushed Application\n\nformat specified above, but use the \ndocker-app\n or \ndocker-app-broker\n type instead\nof just \napp\n or \napp-broker\n. The docker image to be used is then specified using\nthe \nimage\n property:\n\n\n\n- name: app1\n  type: docker-app\n  image: test/dockerimage\n  manifest:\n    ...\n\n\n\n\nIf this app is also a service broker, use \ndocker-app-broker\n instead of just\n\ndocker-app\n. This option is appropriate for docker-wrapped 12-factor apps that\ndelegate their persistence to bound services.\n\n\nDocker applications that require persistent storage can not be deployed into\nthe Elastic Runtime. These can be deployed to separate BOSH-managed VMs instead\nby using the \ndocker-bosh\n type:\n\n\n\n- name: docker-bosh1\n  type: docker-bosh\n  cpu: 5\n  memory: 4096\n  ephemeral_disk: 4096\n  persistent_disk: 2048\n  instances: 1\n  manifest: |\n    containers:\n    - name: redis\n      image: \"redis\"\n      command: \"--dir /var/lib/redis/ --appendonly yes\"\n      bind_ports:\n      - \"6379:6379\"\n      bind_volumes:\n      - \"/var/lib/redis\"\n      entrypoint: \"redis-server\"\n      memory: \"256m\"\n      env_vars:\n      - \"EXAMPLE_VAR=1\"\n    - name: mysql\n      image: \"google/mysql\"\n      bind_ports:\n      - \"3306:3306\"\n      bind_volumes:\n      - \"/mysql\"\n    - name: elasticsearch\n      image: \"bosh/elasticsearch\"\n      links:\n      - mysql:db\n      depends_on:\n      - mysql\n      bind_ports:\n      - \"9200:9200\"\n\n\n\n\nIf a docker image cannot be downloaded by BOSH dynamically, its better to provide a ready made docker image and package it as part of the BOSH release. In that case, specify the image as a local file.\n\n\n- name: docker-bosh2\n  type: docker-bosh\n  files:\n  - path: resources/cfplatformeng-docker-tile-example.tgz\n  cpu: 5\n  memory: 4096\n  ephemeral_disk: 4096\n  persistent_disk: 2048\n  instances: 1\n  manifest: |\n    containers:\n    - name: test_docker_image\n      image: \"cfplatformeng/docker-tile-example\"\n      env_vars:\n      - \"EXAMPLE_VAR=1\"\n      # See below on custom forms/variables and binding it to the docker env variable\n      - \"custom_variable_name=((.properties.customer_name.value))\"\n\n\n\nAlso, refer to \ndocker-bosh\n for more details.\n\n\nCustom Forms and Properties\n\n\nYou can pass custom properties to all applications deployed by your tile by adding\nthe to the properties section of \ntile.yml\n:\n\n\nproperties:\n- name: author\n  type: string\n  label: Author\n  value: Tile Ninja\n\n\n\n\nIf you want the properties to be configurable by the tile installer, place them on\na custom for instead:\n\n\nforms:\n- name: custom-form1\n  label: Test Tile\n  description: Custom Properties for Test Tile\n  properties:\n  - name: customer_name\n    type: string\n    label: Full Name\n  - name: street_address\n    type: string\n    label: Street Address\n    description: Address to use for junk mail\n  - name: city\n    type: string\n    label: City\n  - name: zip_code\n    type: string\n    label: ZIP+4\n    default: '90310'\n  - name: country\n    type: dropdown_select\n    label: Country\n    options:\n    - name: country_us\n      label: US\n      default: true\n    - name: country_elsewhere\n      label: Elsewhere\n\n\n\n\nProperties defined in either section will be passed to all pushed applications\nas environment variables (the name of the environment variable will be the same\nas the property name but in ALL_CAPS). They can also be referenced in other parts\nof the configuration file by using \n(( .properties.\nproperty-name\n ))\n instead\nof a hardcoded value.\n\n\nAutomatic Provisioning of Services\n\n\nTile generator automates the provisioning of services. Any application (including\nservice brokers and docker-based applications) that are being pushed into the\nElastic Runtime can automatically be bound to services through the \nauto_services\n\nfeature:\n\n\n\n- name: app1\n  type: app\n  auto_services:\n  - name: p-mysql\n    plan: 100mb-dev\n  - name: p-redis\n\n\n\n\nYou can specify any number of service names, optionally specifying a specific\nplan. During deployment, the generated tile will create an instance of each\nservice if one does not already exist, and then bind that instance to your\npackage.\n\n\nService instances provisioned this way survive updates, but will be deleted\nwhen the tile is uninstalled.\n\n\nNOTE\n that the name is the name of the provided \nservice\n, \nnot\n the \nbroker\n.\nIn many cases these are not the same, and a single broker may even offer\nmultiple services. Use \ncf marketplace\n to see the services and plans\navailable from installed brokers.\n\n\nIf you do not specify a plan, the tile generator will use the first plan\nlisted for the service in the broker catalog. It is a good idea to always\nspecify a service plan. If you \nchange\n the plan between versions of your\ntile, the tile generator will attempt to update the plan while preserving\nthe service (thus not causing data loss during upgrade). If the service\ndoes not support plan changes, this will cause the upgrade to fail.\n\n\nconfigurable_persistence\n is really just a special case of \nauto_services\n,\nletting the user choose between some standard brokers.\n\n\nDeclaring Product Dependencies\n\n\nWhen your product has dependencies on others, you can have Ops Manager\nenforce that dependency by declaring it in your \ntile.yml\n file as follows:\n\n\nrequires_product_versions:\n- name: p-mysql\n  version '~\n 1.7'\n\n\n\n\nIf the required product is not present in the PCF installation, Ops Manager\nwill display a message saying\n\nyour-tile\n requires 'p-mysql' version '~\n 1.7' as a dependency\n, and will\nrefuse to install your tile until that dependency is satisfied.\n\n\nWhen using automatic provisioning of services as described above, it is\noften appropriate to add those products as a dependency. Tile generator can\nnot do this automatically as it can't always determine which product provides\nthe requested service.\n\n\nOrgs and Spaces\n\n\nBy default, the tile generator will create a single new org and space for any\npackages that install into the Elastic Runtime, using the name of the tile and\nappending \n-org\n and \n-space\n, respectively. The default memory quota for a\nnewly created or will be 1024 (1G). You can change any of these defaults by\nspecifying the following properties in \ntile.yml\n:\n\n\n\norg: test-org\norg_quota: 4096\nspace: test-space\n\n\n\n\nSecurity\n\n\nIf your cf packages need outbound access (including access to other packages\nwithin the same tile), you will need to apply an appropriate security group.\nThe following option will remove all constraints on outbound traffic:\n\n\n\napply_open_security_group: true\n\n\n\n\nStemcells\n\n\nThe tile generator will default to a recent stemcell supported by Ops Manager.\nIn most cases the default will be fine, as the stemcell is only used to execute\nCF command lines and/or the docker daemon. But if you have specific stemcell\nrequirements, you can override the defaults in your \ntile.yml\n file by including\na \nstemcell-criteria\n section and replacing the appopriate values:\n\n\n\nstemcell_criteria:\n  os: 'ubunty-trusty'\n  version: '3146.5'     \nNOTE: You must quote the version to force the type to be string\n\n\n\n\n\nVersioning\n\n\nThe tile generator uses semver versioning. By default, \ntile build\n will\ngenerate the next patch release. Major and minor releases can be generated\nby explicitly specifying \ntile build major\n or \ntile build minor\n. Or to\noverride the version number completely, specify a valid semver version on\nthe build command, e.g. \ntile build 3.4.5\n.\n\n\nNo-op content migration rules are generated for every prior release to the\ncurrent release, so that Ops Manager will allow tile upgrades from any\nversion to any newer version. This depends on the existence of the file\n\ntile-history.yml\n. In a pinch, if you need to be able to upgrade from a\nrandom old version to a new one, you can edit that file, or do:\n\n\ntile build \nold-version\n\ntile build \nnew-version\n\n\n\n\n\nThe new tile will then support upgrades from \nold-version\n.\n\n\nExample\n\n\n$ tile build\nname: tibco-bwce\nicon: icon.png\nlabel: TIBCO BusinessWorks Container Edition\ndescription: BusinessWorks edition that supports deploying to Cloud Foundry\nversion: 0.0.2\n\nbosh init release\nbosh generate package cf_cli\nbosh generate package bwce_buildpack\nbosh generate job install_bwce_buildpack\nbosh generate job remove_bwce_buildpack\nbosh create release --final --with-tarball --version 0.0.2\n\ntile generate release\ntile generate metadata\ntile generate errand install_bwce_buildpack\ntile generate errand remove_bwce_buildpack\ntile generate content-migrations\n\ncreated tile tibco-bwce-0.0.2.pivotal\n\n\n\n\nThis tile includes a single large buildpack, and takes less than 15 seconds\nto build including the CF CLI download and the BOSH release generation.\n\n\nSupported Commands\n\n\ninit [\ntile-name\n]\nbuild [patch|minor|major|\nversion\n]\n\n\n\n\nCredits\n\n\n\n\nsparameswaran\n supplied most of the actual template content, originally built as part of \ncf-platform-eng/bosh-generic-sb-release\n\n\nfrodenas\n contributed most of the docker content through \ncloudfoundry-community/docker-boshrelease\n\n\njoshuamckenty\n suggested the jinja template approach he employed in \nopencontrol", 
            "title": "Home"
        }, 
        {
            "location": "/#pcf-tile-generator", 
            "text": "This is a tile generation utility for PCF tiles. Tiles are the\ninstallation package format used by Pivotal's Ops Manager to deploy add-on\nsoftware such as services and their brokers, buildpacks, or anything else\nthat needs to be installable in both public and private cloud deployments.  The current release of the tile generator supports tiles that have any\ncombination of the following package types:   Cloud Foundry Applications  Cloud Foundry Buildpacks  Cloud Foundry Service Brokers (both inside and outside the Elastic Runtime)  Docker images (both inside and outside the Elastic Runtime)", 
            "title": "PCF Tile Generator"
        }, 
        {
            "location": "/#screencast", 
            "text": "For a 7-minute introduction into what it is and does, see this screencast .", 
            "title": "Screencast"
        }, 
        {
            "location": "/#continuous-integration", 
            "text": "The master branch of this repository is being monitored by this Concourse pipeline .\nThe pipeline verifies that:   The tile generator passes all unit tests in  lib/*_unittest.py  The tile generator successfully builds the sample tile in  sample  The generated tile passes all acceptance tests in  ci/acceptance-tests  The generated tile successfully deploys to a current version of PCF  The deployed tile passes all deployment tests in  ci/deployment-tests", 
            "title": "Continuous Integration"
        }, 
        {
            "location": "/#how-to-use", 
            "text": "Check out the tile-generator repo:  bash\ngit clone https://github.com/cf-platform-eng/tile-generator.git    Change to the root directory of the tile generator, and pull down the generator's dependencies:  bash\ncd tile-generator\npip install -r requirements.txt    Add the  bin  directory of tile-generator to your path:  bash\nexport PATH=`pwd`/bin:$PATH  If you expect to frequently use the tile generator, you may want to add this to your shell's startup script, i.e.  .profile    Install the  BOSH CLI    Then, from within the root directory of the project for which you wish to create a tile, initialize it as a tile repo (we recommend that this be a git repo, but this is not required):  bash\ncd  your project dir \ntile init    Edit the generated  tile.yml  file to define your tile (more details below)    Build your tile  bash\ntile build    The generator will first create a BOSH release (in the  release  subdirectory),\nthen wrap that release into a Pivotal tile (in the  product  subdirectory).\nIf required for the installation, it will automatically pull down the latest\nrelease version of the Cloud Foundry CLI.", 
            "title": "How to Use"
        }, 
        {
            "location": "/#building-the-sample", 
            "text": "The repository includes a sample tile that exercises most of the features of the\ntile generator (it is used by the CI pipeline to verify that things work correctly).\nYou can build this sample using the following steps:  cd sample\nsrc/build.sh\ntile build  The sample tile includes a Python application that is re-used in several packages,\nsometimes as an app, sometimes as a service broker. One of the deployments (app3)\nuses the sample application inside a docker image that is currently only modified\nby the CI pipeline. If you modify the sample app, you will have to build your own\ndocker image using the provided  Dockerfile  and change the image name in sample/tile.yml  to include the modified code in app3.", 
            "title": "Building the Sample"
        }, 
        {
            "location": "/#defining-your-tile", 
            "text": "All required configuration for your tile is in the file called  tile.yml . tile init  will create an initial version for you that can serve as a template.\nThe first section in the file describes the general properties of your tile:  name: tile-name # By convention lowercase with dashes\nicon_file: resources/icon.png\nlabel: Brief Text for the Tile Icon\ndescription: Longer description of the tile's purpose  The  icon_file  should be a 128x128 pixel image that will appear on your tile in\nthe Ops Manager GUI. By convention, any resources used by the tile should be\nplaced in the  resources  sub-directory of your repo, although this is not\nmandatory. The  label  text will appear on the tile under your icon.", 
            "title": "Defining your Tile"
        }, 
        {
            "location": "/#packages", 
            "text": "Next you can specify the packages to be included in your tile. The format of\neach package entry depends on the type of package you are adding.", 
            "title": "Packages"
        }, 
        {
            "location": "/#pushed-applications", 
            "text": "Applications (including service brokers) that are being  cf push ed into the\nElastic Runtime use the following format:  \n- name: my-application\n  type: app  or  app-broker\n  manifest:\n     # any options that you would normally specify in a cf manifest.yml, including \n    buildpack:\n    command:\n    domain:\n    host:\n    instances:\n    memory:\n    path:\n    env:\n    services:\n  health_check: none                  # optional \n  configurable_persistence: true      # optional \n  needs_cf_credentials: true          # optional \n  auto_services: p-mysql p-redis      # optional   Note: for applications that are normally pushed as multiple files (node.js for example)\nyou should zip up the project files plus all dependencies into a single zip file, then\nedit tile.yml to point to the zipped file:   cd  your project dir \nzip -r resources/ your project name .zip  list of file and dirs to include in the zip   If your application is a service broker, use  app-broker  as the type instead of just app . The application will then automatically be registered as a broker on install,\nand deleted on uninstall.  health_check  lets you configure the value of the cf cli  --health_check_type \noption. Expect this option to move into the manifest as soon as CF supports it there.\nCurrently, the only valid options are  none  and  port .  configurable_persistence: true  results in the user being able to select a backing\nservice for data persistence. If there is a specific broker you want to use, you can\nuse the  auto-services  feature described below. If you want to bind to an already\nexisting service instance, use the  services  proeprty of the  manifest  instead.  needs_cf_credentials  causes the application to receive two additional environment\nvariables named  CF_ADMIN_USER  and  CF_ADMIN_PASSWORD  with the admin credentials\nfor the Elastic Runtime into which they are being deployed. This allows apps and\nservices to interact with the Cloud Controller.  auto_services  is described in more detail below.", 
            "title": "Pushed Applications"
        }, 
        {
            "location": "/#service-brokers", 
            "text": "Most modern service brokers are pushed into the Elastic Runtime as normal\nCF applications. For these types of brokers, use the Pushed Application format\nspecified above, but set the type to  app-broker  or  docker-app-broker  instead\nof just  app  or  docker-app .  Some service brokers support operator-defined service plans, for instance when\nthe plans reflect customer license keys. To allow operators to add plans from\nthe tile configuration, add the following section:  \ndynamic_service_plans:\n- name: description\n  type: string\n  description: \"Some Description\"\n  configurable: true\n- name: key1\n  type: integer\n  description: \"Key 1 of type integer\"\n  configurable: true\n- name: key2\n  type: secret\n  description: \"Key 2 of type Password\"\n  configurable: true  Name and GUID fields will be supplied by default for each plan, but all other fields\nare optional and customizable.  For an external service broker, use:  \n- name: my-application\n  type: external-broker\n  uri: http://broker3.example.com\n  username: user\n  password:  secret \n  internal_service_names: 'service1,service2'", 
            "title": "Service Brokers"
        }, 
        {
            "location": "/#buildpacks", 
            "text": "- name: my-buildpack\n  type: buildpack\n  files:\n  - path: resources/buildpack.zip", 
            "title": "Buildpacks"
        }, 
        {
            "location": "/#docker-images", 
            "text": "Applications packages as docker images can be deployed inside or outside the Elastic\nRuntime. To push a docker image as a CF application, use the  Pushed Application \nformat specified above, but use the  docker-app  or  docker-app-broker  type instead\nof just  app  or  app-broker . The docker image to be used is then specified using\nthe  image  property:  \n- name: app1\n  type: docker-app\n  image: test/dockerimage\n  manifest:\n    ...  If this app is also a service broker, use  docker-app-broker  instead of just docker-app . This option is appropriate for docker-wrapped 12-factor apps that\ndelegate their persistence to bound services.  Docker applications that require persistent storage can not be deployed into\nthe Elastic Runtime. These can be deployed to separate BOSH-managed VMs instead\nby using the  docker-bosh  type:  \n- name: docker-bosh1\n  type: docker-bosh\n  cpu: 5\n  memory: 4096\n  ephemeral_disk: 4096\n  persistent_disk: 2048\n  instances: 1\n  manifest: |\n    containers:\n    - name: redis\n      image: \"redis\"\n      command: \"--dir /var/lib/redis/ --appendonly yes\"\n      bind_ports:\n      - \"6379:6379\"\n      bind_volumes:\n      - \"/var/lib/redis\"\n      entrypoint: \"redis-server\"\n      memory: \"256m\"\n      env_vars:\n      - \"EXAMPLE_VAR=1\"\n    - name: mysql\n      image: \"google/mysql\"\n      bind_ports:\n      - \"3306:3306\"\n      bind_volumes:\n      - \"/mysql\"\n    - name: elasticsearch\n      image: \"bosh/elasticsearch\"\n      links:\n      - mysql:db\n      depends_on:\n      - mysql\n      bind_ports:\n      - \"9200:9200\"  If a docker image cannot be downloaded by BOSH dynamically, its better to provide a ready made docker image and package it as part of the BOSH release. In that case, specify the image as a local file. \n- name: docker-bosh2\n  type: docker-bosh\n  files:\n  - path: resources/cfplatformeng-docker-tile-example.tgz\n  cpu: 5\n  memory: 4096\n  ephemeral_disk: 4096\n  persistent_disk: 2048\n  instances: 1\n  manifest: |\n    containers:\n    - name: test_docker_image\n      image: \"cfplatformeng/docker-tile-example\"\n      env_vars:\n      - \"EXAMPLE_VAR=1\"\n      # See below on custom forms/variables and binding it to the docker env variable\n      - \"custom_variable_name=((.properties.customer_name.value))\"  Also, refer to  docker-bosh  for more details.", 
            "title": "Docker Images"
        }, 
        {
            "location": "/#custom-forms-and-properties", 
            "text": "You can pass custom properties to all applications deployed by your tile by adding\nthe to the properties section of  tile.yml :  properties:\n- name: author\n  type: string\n  label: Author\n  value: Tile Ninja  If you want the properties to be configurable by the tile installer, place them on\na custom for instead:  forms:\n- name: custom-form1\n  label: Test Tile\n  description: Custom Properties for Test Tile\n  properties:\n  - name: customer_name\n    type: string\n    label: Full Name\n  - name: street_address\n    type: string\n    label: Street Address\n    description: Address to use for junk mail\n  - name: city\n    type: string\n    label: City\n  - name: zip_code\n    type: string\n    label: ZIP+4\n    default: '90310'\n  - name: country\n    type: dropdown_select\n    label: Country\n    options:\n    - name: country_us\n      label: US\n      default: true\n    - name: country_elsewhere\n      label: Elsewhere  Properties defined in either section will be passed to all pushed applications\nas environment variables (the name of the environment variable will be the same\nas the property name but in ALL_CAPS). They can also be referenced in other parts\nof the configuration file by using  (( .properties. property-name  ))  instead\nof a hardcoded value.", 
            "title": "Custom Forms and Properties"
        }, 
        {
            "location": "/#automatic-provisioning-of-services", 
            "text": "Tile generator automates the provisioning of services. Any application (including\nservice brokers and docker-based applications) that are being pushed into the\nElastic Runtime can automatically be bound to services through the  auto_services \nfeature:  \n- name: app1\n  type: app\n  auto_services:\n  - name: p-mysql\n    plan: 100mb-dev\n  - name: p-redis  You can specify any number of service names, optionally specifying a specific\nplan. During deployment, the generated tile will create an instance of each\nservice if one does not already exist, and then bind that instance to your\npackage.  Service instances provisioned this way survive updates, but will be deleted\nwhen the tile is uninstalled.  NOTE  that the name is the name of the provided  service ,  not  the  broker .\nIn many cases these are not the same, and a single broker may even offer\nmultiple services. Use  cf marketplace  to see the services and plans\navailable from installed brokers.  If you do not specify a plan, the tile generator will use the first plan\nlisted for the service in the broker catalog. It is a good idea to always\nspecify a service plan. If you  change  the plan between versions of your\ntile, the tile generator will attempt to update the plan while preserving\nthe service (thus not causing data loss during upgrade). If the service\ndoes not support plan changes, this will cause the upgrade to fail.  configurable_persistence  is really just a special case of  auto_services ,\nletting the user choose between some standard brokers.", 
            "title": "Automatic Provisioning of Services"
        }, 
        {
            "location": "/#declaring-product-dependencies", 
            "text": "When your product has dependencies on others, you can have Ops Manager\nenforce that dependency by declaring it in your  tile.yml  file as follows:  requires_product_versions:\n- name: p-mysql\n  version '~  1.7'  If the required product is not present in the PCF installation, Ops Manager\nwill display a message saying your-tile  requires 'p-mysql' version '~  1.7' as a dependency , and will\nrefuse to install your tile until that dependency is satisfied.  When using automatic provisioning of services as described above, it is\noften appropriate to add those products as a dependency. Tile generator can\nnot do this automatically as it can't always determine which product provides\nthe requested service.", 
            "title": "Declaring Product Dependencies"
        }, 
        {
            "location": "/#orgs-and-spaces", 
            "text": "By default, the tile generator will create a single new org and space for any\npackages that install into the Elastic Runtime, using the name of the tile and\nappending  -org  and  -space , respectively. The default memory quota for a\nnewly created or will be 1024 (1G). You can change any of these defaults by\nspecifying the following properties in  tile.yml :  \norg: test-org\norg_quota: 4096\nspace: test-space", 
            "title": "Orgs and Spaces"
        }, 
        {
            "location": "/#security", 
            "text": "If your cf packages need outbound access (including access to other packages\nwithin the same tile), you will need to apply an appropriate security group.\nThe following option will remove all constraints on outbound traffic:  \napply_open_security_group: true", 
            "title": "Security"
        }, 
        {
            "location": "/#stemcells", 
            "text": "The tile generator will default to a recent stemcell supported by Ops Manager.\nIn most cases the default will be fine, as the stemcell is only used to execute\nCF command lines and/or the docker daemon. But if you have specific stemcell\nrequirements, you can override the defaults in your  tile.yml  file by including\na  stemcell-criteria  section and replacing the appopriate values:  \nstemcell_criteria:\n  os: 'ubunty-trusty'\n  version: '3146.5'      NOTE: You must quote the version to force the type to be string", 
            "title": "Stemcells"
        }, 
        {
            "location": "/#versioning", 
            "text": "The tile generator uses semver versioning. By default,  tile build  will\ngenerate the next patch release. Major and minor releases can be generated\nby explicitly specifying  tile build major  or  tile build minor . Or to\noverride the version number completely, specify a valid semver version on\nthe build command, e.g.  tile build 3.4.5 .  No-op content migration rules are generated for every prior release to the\ncurrent release, so that Ops Manager will allow tile upgrades from any\nversion to any newer version. This depends on the existence of the file tile-history.yml . In a pinch, if you need to be able to upgrade from a\nrandom old version to a new one, you can edit that file, or do:  tile build  old-version \ntile build  new-version   The new tile will then support upgrades from  old-version .", 
            "title": "Versioning"
        }, 
        {
            "location": "/#example", 
            "text": "$ tile build\nname: tibco-bwce\nicon: icon.png\nlabel: TIBCO BusinessWorks Container Edition\ndescription: BusinessWorks edition that supports deploying to Cloud Foundry\nversion: 0.0.2\n\nbosh init release\nbosh generate package cf_cli\nbosh generate package bwce_buildpack\nbosh generate job install_bwce_buildpack\nbosh generate job remove_bwce_buildpack\nbosh create release --final --with-tarball --version 0.0.2\n\ntile generate release\ntile generate metadata\ntile generate errand install_bwce_buildpack\ntile generate errand remove_bwce_buildpack\ntile generate content-migrations\n\ncreated tile tibco-bwce-0.0.2.pivotal  This tile includes a single large buildpack, and takes less than 15 seconds\nto build including the CF CLI download and the BOSH release generation.", 
            "title": "Example"
        }, 
        {
            "location": "/#supported-commands", 
            "text": "init [ tile-name ]\nbuild [patch|minor|major| version ]", 
            "title": "Supported Commands"
        }, 
        {
            "location": "/#credits", 
            "text": "sparameswaran  supplied most of the actual template content, originally built as part of  cf-platform-eng/bosh-generic-sb-release  frodenas  contributed most of the docker content through  cloudfoundry-community/docker-boshrelease  joshuamckenty  suggested the jinja template approach he employed in  opencontrol", 
            "title": "Credits"
        }
    ]
}